name: Dashboard

on:
  schedule:
    - cron: "15 * * * *" # 每小时第15分钟（UTC）跑一次；可按需调整
  workflow_dispatch: {}

permissions:
  issues: read
  contents: write

concurrency:
  group: dashboard
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate docs/dashboard.md
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const REQUIRED_LABEL = 'sleep-log';
            const DAYS_AVG = 7;

            const TRUSTED_EVENT_AUTHOR = 'github-actions[bot]';
            const EVENT_PREFIX = '<!--SLEEP_LOG_EVENT ';
            const EVENT_SUFFIX = '-->';

            const pad = (n) => String(n).padStart(2, '0');

            function toUtc8Date(dateUtcIso) {
              const dt = new Date(dateUtcIso);
              return new Date(dt.getTime() + 8 * 60 * 60 * 1000);
            }

            function fmtUtc8DateKey(dUtc8) {
              const yyyy = dUtc8.getUTCFullYear();
              const mm = pad(dUtc8.getUTCMonth() + 1);
              const dd = pad(dUtc8.getUTCDate());
              return `${yyyy}-${mm}-${dd}`;
            }

            function addDaysToUtc8DateKey(dateKey, deltaDays) {
              const m = dateKey.match(/^(\d{4})-(\d{2})-(\d{2})$/);
              if (!m) return null;
              const [, Y, M, D] = m;
              const utcMs = Date.UTC(Number(Y), Number(M) - 1, Number(D), -8, 0, 0);
              const newUtcMs = utcMs + deltaDays * 24 * 60 * 60 * 1000;
              const newUtc8 = new Date(newUtcMs + 8 * 60 * 60 * 1000);
              return fmtUtc8DateKey(newUtc8);
            }

            function minutesBetweenUtc8Stamps(sleepStamp, wakeStamp) {
              const m1 = (sleepStamp || '').match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})$/);
              const m2 = (wakeStamp || '').match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})$/);
              if (!m1 || !m2) return null;

              const [, Y1, M1, D1, h1, mi1] = m1;
              const [, Y2, M2, D2, h2, mi2] = m2;

              const t1 = Date.UTC(Number(Y1), Number(M1) - 1, Number(D1), Number(h1) - 8, Number(mi1));
              const t2 = Date.UTC(Number(Y2), Number(M2) - 1, Number(D2), Number(h2) - 8, Number(mi2));
              return Math.round((t2 - t1) / 60000);
            }

            function computeDurationStr(sleepStamp, wakeStamp) {
              if (!sleepStamp || !wakeStamp) return '';
              const diffMin = minutesBetweenUtc8Stamps(sleepStamp, wakeStamp);
              if (diffMin == null || diffMin < 0 || diffMin > 24 * 60) return '';
              return `${Math.floor(diffMin / 60)}h${pad(diffMin % 60)}m`;
            }

            function parseDurationToMinutes(d) {
              const m = (d || '').match(/^(\d+)h(\d{2})m$/);
              if (!m) return null;
              return Number(m[1]) * 60 + Number(m[2]);
            }

            function parseEventFromCommentBody(body) {
              if (!body) return null;
              const start = body.indexOf(EVENT_PREFIX);
              if (start < 0) return null;

              const jsonStart = start + EVENT_PREFIX.length;
              const end = body.indexOf(EVENT_SUFFIX, jsonStart);
              if (end < 0) return null;

              const jsonText = body.slice(jsonStart, end).trim();
              try {
                const evt = JSON.parse(jsonText);
                if (!evt || typeof evt !== 'object') return null;
                if (evt.cmd !== 'sleep' && evt.cmd !== 'wake' && evt.cmd !== 'undo') return null;
                if (typeof evt.id !== 'number') return null;

                if (evt.cmd === 'undo') {
                  if (typeof evt.revokes !== 'number') return null;
                  evt.source = evt.source || 'live';
                  return evt;
                }

                if (!evt.stamp || !evt.dateKey) return null;
                if (!/^\d{4}-\d{2}-\d{2}$/.test(evt.dateKey)) return null;
                if (!/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/.test(evt.stamp)) return null;
                evt.source = evt.source || 'live';
                return evt;
              } catch {
                return null;
              }
            }

            async function listAllComments(owner, repo, issue_number) {
              return await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number,
                per_page: 100,
              });
            }

            function buildRowsFromEvents(events) {
              const revoked = new Set();
              for (const evt of events) {
                if (evt.cmd === 'undo') revoked.add(evt.revokes);
              }

              // Map<dateKey, {sleep,wake,source}>
              const map = new Map();

              for (const evt of events) {
                if (evt.cmd === 'undo') continue;
                if (revoked.has(evt.id)) continue;

                const e = map.get(evt.dateKey) || { sleep: '', wake: '', source: '' };

                if (evt.cmd === 'sleep') {
                  if (!e.sleep || evt.stamp >= e.sleep) e.sleep = evt.stamp;
                } else {
                  if (!e.wake || evt.stamp >= e.wake) e.wake = evt.stamp;
                }

                if (e.source !== 'backfill') e.source = evt.source || 'live';

                map.set(evt.dateKey, e);
              }

              const rows = [];
              for (const [dateKey, e] of map.entries()) {
                rows.push({
                  date: dateKey,
                  sleep: e.sleep,
                  wake: e.wake,
                  duration: computeDurationStr(e.sleep, e.wake),
                  source: e.source || '',
                });
              }

              rows.sort((a, b) => (a.date < b.date ? 1 : -1));
              return rows;
            }

            const nowUtc8 = toUtc8Date(new Date().toISOString());
            const todayKey = fmtUtc8DateKey(nowUtc8);
            const minKey = addDaysToUtc8DateKey(todayKey, -(DAYS_AVG - 1));

            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: REQUIRED_LABEL,
              per_page: 100,
            });

            const people = [];
            for (const is of issues) {
              const author = is.user?.login || 'unknown';

              const comments = await listAllComments(context.repo.owner, context.repo.repo, is.number);
              const events = [];
              for (const c of comments) {
                if (c.user?.login !== TRUSTED_EVENT_AUTHOR) continue;
                const evt = parseEventFromCommentBody(c.body || '');
                if (!evt) continue;
                // defense-in-depth: ensure id matches comment id
                if (evt.id !== c.id) continue;
                events.push(evt);
              }

              people.push({
                author,
                issue_number: is.number,
                issue_title: is.title,
                issue_url: is.html_url,
                rows: buildRowsFromEvents(events),
              });
            }

            people.sort((a, b) => a.author.localeCompare(b.author));

            const todayRecords = people.map((p) => {
              const row = p.rows.find((r) => r.date === todayKey) || { sleep: '', wake: '', duration: '', source: '' };
              return {
                user: p.author,
                sleep: row.sleep || '',
                wake: row.wake || '',
                duration: row.duration || '',
                source: row.source || '',
                issue: p.issue_url,
              };
            });

            const averages = people.map((p) => {
              const mins = [];
              for (const r of p.rows) {
                if (!r.date || !minKey) continue;
                if (r.date < minKey || r.date > todayKey) continue;
                const m = parseDurationToMinutes(r.duration);
                if (m != null) mins.push(m);
              }
              const avgMin = mins.length ? Math.round(mins.reduce((x, y) => x + y, 0) / mins.length) : null;
              const avg = avgMin == null ? '' : `${Math.floor(avgMin / 60)}h${pad(avgMin % 60)}m`;
              return {
                user: p.author,
                avg,
                days_counted: mins.length,
                issue: p.issue_url,
              };
            });

            const lines = [];
            lines.push(`# Sleep Check-in Dashboard`);
            lines.push('');
            lines.push(`Updated: ${new Date().toISOString()}`);
            lines.push('');
            lines.push(`- Data source: trusted event comments from **${TRUSTED_EVENT_AUTHOR}** (anti-tamper).`);
            lines.push(`- Supports \`/undo\`: revoked events are excluded from tables/averages.`);
            lines.push(`- "Today" uses the table's **Date (sleep dateKey)**.`);
            lines.push(`- "Avg" is computed from rows with a valid \`Duration\` in the last ${DAYS_AVG} days (${minKey} ~ ${todayKey}).`);
            lines.push('');

            lines.push(`## Today (${todayKey})`);
            lines.push('');
            lines.push(`| User | Sleep (UTC+8) | Wake (UTC+8) | Duration | Source | Issue |`);
            lines.push(`|---|---|---|---|---|---|`);
            for (const r of todayRecords) {
              lines.push(`| @${r.user} | ${r.sleep} | ${r.wake} | ${r.duration} | ${r.source} | ${r.issue} |`);
            }
            lines.push('');

            lines.push(`## Average sleep duration (last ${DAYS_AVG} days)`);
            lines.push('');
            lines.push(`| User | Avg Duration | Days Counted | Issue |`);
            lines.push(`|---|---:|---:|---|`);
            for (const a of averages.sort((x, y) => x.user.localeCompare(y.user))) {
              lines.push(`| @${a.user} | ${a.avg} | ${a.days_counted} | ${a.issue} |`);
            }
            lines.push('');

            fs.mkdirSync('docs', { recursive: true });
            fs.writeFileSync('docs/dashboard.md', lines.join('\n'), 'utf8');

      - name: Commit and push dashboard
        run: |
          if git diff --quiet; then
            echo "No changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/dashboard.md
          git commit -m "Update dashboard"
          git push
