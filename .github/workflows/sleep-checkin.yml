name: Sleep check-in

on:
  issue_comment:
    types: [created]

permissions:
  issues: write

concurrency:
  group: sleep-checkin-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  log:
    if: ${{ github.event.issue.pull_request == null }}
    runs-on: ubuntu-latest
    steps:
      - name: Handle /sleep /wake /rebuild
        uses: actions/github-script@v7
        with:
          script: |
            // ----------------------------
            // Config
            // ----------------------------
            const REQUIRED_LABEL = 'sleep-log';

            const BACKFILL_LABEL = 'backfill';
            const BACKFILL_KEYWORD = 'backfill';
            const BACKFILL_MAX_DAYS = 7;

            // 04:00 (UTC+8): sleep before this hour counts as "previous night" (dateKey - 1 day)
            const CUTOFF_HOUR = 4;

            // Title format
            const TITLE_PREFIX = '[Sleep Log]';

            // Anti-tamper: only trust events emitted by github-actions[bot]
            const TRUSTED_EVENT_AUTHOR = 'github-actions[bot]';
            const EVENT_PREFIX = '<!--SLEEP_LOG_EVENT ';
            const EVENT_SUFFIX = '-->';

            // ----------------------------
            // Helpers
            // ----------------------------
            const pad = (n) => String(n).padStart(2, '0');

            function toUtc8Date(dateUtcIso) {
              const dt = new Date(dateUtcIso); // UTC
              return new Date(dt.getTime() + 8 * 60 * 60 * 1000);
            }

            function fmtUtc8Stamp(dateObjUtc8) {
              const yyyy = dateObjUtc8.getUTCFullYear();
              const mm = pad(dateObjUtc8.getUTCMonth() + 1);
              const dd = pad(dateObjUtc8.getUTCDate());
              const HH = pad(dateObjUtc8.getUTCHours());
              const MM = pad(dateObjUtc8.getUTCMinutes());
              return `${yyyy}-${mm}-${dd} ${HH}:${MM}`;
            }

            function fmtUtc8DateKey(dateObjUtc8) {
              const yyyy = dateObjUtc8.getUTCFullYear();
              const mm = pad(dateObjUtc8.getUTCMonth() + 1);
              const dd = pad(dateObjUtc8.getUTCDate());
              return `${yyyy}-${mm}-${dd}`;
            }

            function addDaysToUtc8DateKey(dateKey, deltaDays) {
              const m = dateKey.match(/^(\d{4})-(\d{2})-(\d{2})$/);
              if (!m) return null;

              const [, Y, M, D] = m;

              // UTC+8 midnight -> UTC time = midnight - 8h
              const utcMs = Date.UTC(Number(Y), Number(M) - 1, Number(D), -8, 0, 0);
              const newUtcMs = utcMs + deltaDays * 24 * 60 * 60 * 1000;
              const newUtc8 = new Date(newUtcMs + 8 * 60 * 60 * 1000);
              return fmtUtc8DateKey(newUtc8);
            }

            function minutesBetweenUtc8Stamps(sleepStamp, wakeStamp) {
              const m1 = sleepStamp.match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})$/);
              const m2 = wakeStamp.match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})$/);
              if (!m1 || !m2) return null;

              const [, Y1, M1, D1, h1, mi1] = m1;
              const [, Y2, M2, D2, h2, mi2] = m2;

              const t1 = Date.UTC(Number(Y1), Number(M1) - 1, Number(D1), Number(h1) - 8, Number(mi1));
              const t2 = Date.UTC(Number(Y2), Number(M2) - 1, Number(D2), Number(h2) - 8, Number(mi2));
              return Math.round((t2 - t1) / 60000);
            }

            function ensureTableBlock(issueBody) {
              const startMark = '<!-- SLEEP_LOG_TABLE_START -->';
              const endMark = '<!-- SLEEP_LOG_TABLE_END -->';

              let body = issueBody || '';
              if (!body.includes(startMark) || !body.includes(endMark)) {
                body =
                  `${body}\n\n${startMark}\n\n` +
                  `| Date | Sleep (UTC+8) | Wake (UTC+8) | Duration | Source |\n` +
                  `|---|---|---|---|---|\n\n` +
                  `${endMark}\n`;
              }
              return { body, startMark, endMark };
            }

            function extractTable(body, startMark, endMark) {
              const startIdx = body.indexOf(startMark);
              const endIdx = body.indexOf(endMark);
              const before = body.slice(0, startIdx + startMark.length);
              const middle = body.slice(startIdx + startMark.length, endIdx);
              const after = body.slice(endIdx);
              return { before, middle, after };
            }

            function rebuildMiddleFromMap(map) {
              const keys = Array.from(map.keys()).sort((a, b) => (a < b ? 1 : -1)); // desc
              const out = [
                '| Date | Sleep (UTC+8) | Wake (UTC+8) | Duration | Source |',
                '|---|---|---|---|---|',
                ...keys.map((k) => {
                  const e = map.get(k);
                  return `| ${k} | ${e.sleep || ''} | ${e.wake || ''} | ${e.duration || ''} | ${e.source || ''} |`;
                }),
              ];
              return `\n\n${out.join('\n')}\n\n`;
            }

            function computeDuration(entry) {
              entry.duration = '';

              if (entry.sleep && entry.wake) {
                const diffMin = minutesBetweenUtc8Stamps(entry.sleep, entry.wake);
                if (diffMin != null && diffMin >= 0 && diffMin <= 24 * 60) {
                  const h = Math.floor(diffMin / 60);
                  const m = diffMin % 60;
                  entry.duration = `${h}h${pad(m)}m`;
                } else {
                  entry.duration = '';
                }
              }
            }

            function dateKeyForSleepEvent(utc8DateObj) {
              const hour = utc8DateObj.getUTCHours();
              const todayKey = fmtUtc8DateKey(utc8DateObj);
              if (hour < CUTOFF_HOUR) return addDaysToUtc8DateKey(todayKey, -1);
              return todayKey;
            }

            function parseCommand(text) {
              // Supported:
              // /sleep
              // /wake
              // /sleep YYYY-MM-DD HH:MM backfill
              // /wake  YYYY-MM-DD HH:MM backfill
              // /rebuild
              const parts = (text || '').trim().split(/\s+/).filter(Boolean);
              const cmd = (parts[0] || '').toLowerCase();

              if (cmd === '/rebuild') return { cmd };

              if (cmd !== '/sleep' && cmd !== '/wake') return null;

              let explicitDate = null;
              let explicitTime = null;
              let isBackfill = false;

              if (parts.length === 2) {
                // Disallow "/sleep HH:MM" and "/wake HH:MM" (no date)
                if (/^\d{2}:\d{2}$/.test(parts[1])) {
                  explicitTime = parts[1];
                }
              } else if (parts.length >= 3) {
                if (/^\d{4}-\d{2}-\d{2}$/.test(parts[1]) && /^\d{2}:\d{2}$/.test(parts[2])) {
                  explicitDate = parts[1];
                  explicitTime = parts[2];
                  isBackfill = parts
                    .slice(3)
                    .map((s) => s.toLowerCase())
                    .includes(BACKFILL_KEYWORD);
                }
              }

              return { cmd, explicitDate, explicitTime, isBackfill };
            }

            function parseEventFromCommentBody(body) {
              if (!body) return null;
              const start = body.indexOf(EVENT_PREFIX);
              if (start < 0) return null;

              const jsonStart = start + EVENT_PREFIX.length;
              const end = body.indexOf(EVENT_SUFFIX, jsonStart);
              if (end < 0) return null;

              const jsonText = body.slice(jsonStart, end).trim();
              try {
                const evt = JSON.parse(jsonText);
                if (!evt || typeof evt !== 'object') return null;
                if (evt.cmd !== 'sleep' && evt.cmd !== 'wake') return null;
                if (!evt.stamp || !evt.dateKey) return null;
                if (!/^\d{4}-\d{2}-\d{2}$/.test(evt.dateKey)) return null;
                if (!/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/.test(evt.stamp)) return null;
                evt.source = evt.source || 'live';
                return evt;
              } catch {
                return null;
              }
            }

            async function comment(owner, repo, issue_number, body) {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }

            function buildEventComment(evt) {
              const action = evt.cmd === 'sleep' ? 'Sleep' : 'Wake';
              const extra = evt.source === 'backfill' ? ' (backfill)' : '';
              return (
                `Recorded **${action}**${extra}: **${evt.stamp} (UTC+8)**\n` +
                `${EVENT_PREFIX}${JSON.stringify(evt)} ${EVENT_SUFFIX}`
              );
            }

            async function listAllComments(owner, repo, issue_number) {
              const per_page = 100;
              let page = 1;
              const all = [];

              while (true) {
                const res = await github.rest.issues.listComments({
                  owner,
                  repo,
                  issue_number,
                  per_page,
                  page,
                });

                const items = res.data || [];
                all.push(...items);

                if (items.length < per_page) break;
                page += 1;
              }

              return all;
            }

            async function buildMapFromTrustedEvents(owner, repo, issue_number) {
              const comments = await listAllComments(owner, repo, issue_number);

              // Reduce to dateKey map. Rule: never earlier (keep latest stamp lexicographically)
              const map = new Map();

              for (const c of comments) {
                if (c.user?.login !== TRUSTED_EVENT_AUTHOR) continue;
                const evt = parseEventFromCommentBody(c.body || '');
                if (!evt) continue;

                const e = map.get(evt.dateKey) || { sleep: '', wake: '', duration: '', source: '' };

                if (evt.cmd === 'sleep') {
                  if (!e.sleep || evt.stamp >= e.sleep) e.sleep = evt.stamp;
                } else {
                  if (!e.wake || evt.stamp >= e.wake) e.wake = evt.stamp;
                }

                if (e.source !== 'backfill') e.source = evt.source || 'live';

                computeDuration(e);
                map.set(evt.dateKey, e);
              }

              return map;
            }

            function canSetField(oldStamp, newFullStamp, isBackfill, eventStamp) {
              if (oldStamp) return newFullStamp >= oldStamp;
              if (!isBackfill) return newFullStamp >= eventStamp;
              return true;
            }

            // ----------------------------
            // Start
            // ----------------------------
            const parsed = parseCommand(context.payload.comment.body);
            if (!parsed) return;

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.issue.number;

            // Read issue
            const issueRes = await github.rest.issues.get({ owner, repo, issue_number });
            const issue = issueRes.data;

            const commenter = context.payload.comment.user.login;
            const issueAuthor = issue.user?.login;

            // Only allow issue author
            if (!issueAuthor || commenter !== issueAuthor) return;

            // Auto-update title to include author login (best-effort)
            const desiredTitle = `${TITLE_PREFIX} @${issueAuthor}`;
            if (!issue.title?.includes(`@${issueAuthor}`)) {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number,
                title: desiredTitle,
              });
            }

            // Must have required label (or auto-add it)
            let labels = (issue.labels || [])
              .map((l) => (typeof l === 'string' ? l : l.name))
              .filter(Boolean);

            if (!labels.includes(REQUIRED_LABEL)) {
              const issueBody = issue.body || '';
              const hasMarker = issueBody.includes('<!-- SLEEP_LOG_ENABLED -->');

              if (hasMarker) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number,
                  labels: [REQUIRED_LABEL],
                });
                labels.push(REQUIRED_LABEL);

                await comment(owner, repo, issue_number, `@${commenter} âœ… å·²è‡ªåŠ¨å¯ç”¨ sleep-log åŠŸèƒ½ã€‚`);
              } else {
                return;
              }
            }

            // Helper: rebuild table from trusted events and overwrite body table block
            const applyRebuild = async () => {
              const map = await buildMapFromTrustedEvents(owner, repo, issue_number);

              // Use latest issue body (refetch once to reduce stale overwrite risk)
              const latestIssueRes = await github.rest.issues.get({ owner, repo, issue_number });
              const latestIssue = latestIssueRes.data;

              const { body: ensuredBody, startMark, endMark } = ensureTableBlock(latestIssue.body || '');
              const { before, after } = extractTable(ensuredBody, startMark, endMark);
              const rebuiltMiddle = rebuildMiddleFromMap(map);
              const finalBody = before + rebuiltMiddle + after;

              await github.rest.issues.update({
                owner,
                repo,
                issue_number,
                body: finalBody,
              });

              return map;
            };

            // â­ Scheme A: always rebuild first to undo any manual edits, even if command will be rejected later
            // (But if there are no trusted events yet, this rebuild may produce an empty table; that's expected.)
            let map = await applyRebuild();

            if (parsed.cmd === '/rebuild') {
              await comment(owner, repo, issue_number, `@${commenter} âœ… å·²ä»äº‹ä»¶æ—¥å¿—é‡å»ºè¡¨æ ¼ã€‚`);
              return;
            }

            // Event time (UTC+8)
            const eventUtc8 = toUtc8Date(context.payload.comment.created_at);
            const eventStamp = fmtUtc8Stamp(eventUtc8);
            const eventDateKey = fmtUtc8DateKey(eventUtc8);

            // Find latest incomplete sleep row (Sleep set, Wake empty), newest date first
            const findLatestIncompleteDateKey = () => {
              const keys = Array.from(map.keys()).sort((a, b) => (a < b ? 1 : -1));
              for (const k of keys) {
                const e = map.get(k);
                if (e && e.sleep && !e.wake) return k;
              }
              return null;
            };

            // Resolve target
            let appliedDateKey = null;
            let targetStamp = null; // always full "YYYY-MM-DD HH:MM" in UTC+8
            let source = 'live';

            if (!parsed.explicitTime) {
              if (parsed.cmd === '/sleep') {
                appliedDateKey = dateKeyForSleepEvent(eventUtc8);
                targetStamp = eventStamp;
              } else {
                appliedDateKey = findLatestIncompleteDateKey() || eventDateKey;
                targetStamp = eventStamp;
              }
            } else if (parsed.explicitTime && !parsed.explicitDate) {
              await comment(
                owner,
                repo,
                issue_number,
                `@${commenter} âš ï¸ ä¸æ”¯æŒ \`${parsed.cmd} HH:MM\` æ ¼å¼ã€‚\n` +
                  `è¯·ä½¿ç”¨ï¼š\n` +
                  `- \`${parsed.cmd}\` è®°å½•å½“å‰æ—¶é—´\n` +
                  `- \`${parsed.cmd} YYYY-MM-DD HH:MM backfill\` è¡¥è®°/ä¿®æ­£ï¼ˆä»…å…è®¸æœ€è¿‘ ${BACKFILL_MAX_DAYS} å¤©ï¼‰`
              );
              return;
            } else if (parsed.explicitDate && parsed.explicitTime) {
              if (!parsed.isBackfill) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} âš ï¸ æŒ‡å®šæ—¥æœŸå’Œæ—¶é—´ä¿®æ”¹è®°å½•æ—¶ï¼Œå¿…é¡»åœ¨å‘½ä»¤æœ«å°¾åŠ ä¸Š \`backfill\` å…³é”®å­—ã€‚\n` +
                    `æ­£ç¡®æ ¼å¼ï¼š\`${parsed.cmd} ${parsed.explicitDate} ${parsed.explicitTime} backfill\``
                );
                return;
              }

              appliedDateKey = parsed.explicitDate;
              targetStamp = `${parsed.explicitDate} ${parsed.explicitTime}`;
              source = 'backfill';

              // Enforce 7-day window
              const todayKey = eventDateKey;
              const minAllowed = addDaysToUtc8DateKey(todayKey, -BACKFILL_MAX_DAYS);

              if (minAllowed && (appliedDateKey < minAllowed || appliedDateKey > todayKey)) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} âš ï¸ Backfill ä»…å…è®¸æœ€è¿‘ **${BACKFILL_MAX_DAYS}** å¤©ï¼ˆ**${minAllowed}** ~ **${todayKey}**ï¼‰ã€‚\n` +
                    `ä½ å°è¯•ä¿®æ”¹çš„æ—¥æœŸï¼š**${appliedDateKey}**`
                );
                return;
              }
            }

            if (!appliedDateKey || !targetStamp) return;

            const entry = map.get(appliedDateKey) || { sleep: '', wake: '', duration: '', source: '' };

            // Enforce "only once per day" unless backfill
            if (parsed.cmd === '/sleep' && entry.sleep && source !== 'backfill') {
              await comment(
                owner,
                repo,
                issue_number,
                `@${commenter} ${appliedDateKey} å·²ç»è®°å½•è¿‡ **Sleep**ï¼š**${entry.sleep}**ã€‚\n` +
                  `å¦‚éœ€ä¿®æ­£ï¼Œè¯·ä½¿ç”¨ï¼š\n` +
                  `\`/sleep ${appliedDateKey} HH:MM backfill\`\n` +
                  `ï¼ˆä»…å…è®¸æœ€è¿‘ ${BACKFILL_MAX_DAYS} å¤©ï¼Œä¸”åªèƒ½æŠŠæ—¶é—´æ”¹å¾—æ›´æ™šï¼‰`
              );
              return;
            }

            if (parsed.cmd === '/wake' && entry.wake && source !== 'backfill') {
              await comment(
                owner,
                repo,
                issue_number,
                `@${commenter} ${appliedDateKey} å·²ç»è®°å½•è¿‡ **Wake**ï¼š**${entry.wake}**ã€‚\n` +
                  `å¦‚éœ€ä¿®æ­£ï¼Œè¯·ä½¿ç”¨ï¼š\n` +
                  `\`/wake ${appliedDateKey} HH:MM backfill\`\n` +
                  `ï¼ˆä»…å…è®¸æœ€è¿‘ ${BACKFILL_MAX_DAYS} å¤©ï¼Œä¸”åªèƒ½æŠŠæ—¶é—´æ”¹å¾—æ›´æ™šï¼‰`
              );
              return;
            }

            // Handle /sleep
            if (parsed.cmd === '/sleep') {
              if (entry.wake && targetStamp >= entry.wake) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} âŒ ä¸èƒ½æŠŠ **Sleep** è®¾ä¸º **${targetStamp}**ï¼Œå› ä¸ºå®ƒæ™šäºæˆ–ç­‰äºå·²è®°å½•çš„ **Wake**ï¼ˆ**${entry.wake}**ï¼‰ã€‚\n` +
                    `ğŸ’¡ å¦‚éœ€ä¿®æ­£ï¼Œè¯·å…ˆç”¨ backfill ä¿®æ­£ Wakeï¼Œæˆ–æ£€æŸ¥æ—¶é—´ã€‚`
                );
                return;
              }

              if (!canSetField(entry.sleep, targetStamp, source === 'backfill', eventStamp)) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ä¸å…è®¸æŠŠ **Sleep** æ”¹å¾—æ›´æ—©ã€‚\nå½“å‰ï¼š**${entry.sleep || '(empty)'}**\nå°è¯•ï¼š**${targetStamp}**`
                );
                return;
              }

              entry.sleep = targetStamp;
            } else {
              // Handle /wake
              if (entry.sleep && targetStamp <= entry.sleep) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} âŒ ä¸èƒ½æŠŠ **Wake** è®¾ä¸º **${targetStamp}**ï¼Œå› ä¸ºå®ƒæ—©äºæˆ–ç­‰äºå·²è®°å½•çš„ **Sleep**ï¼ˆ**${entry.sleep}**ï¼‰ã€‚\n` +
                    `ğŸ’¡ å¦‚éœ€ä¿®æ­£ï¼Œè¯·å…ˆç”¨ backfill ä¿®æ­£ Sleepï¼Œæˆ–æ£€æŸ¥æ—¶é—´ã€‚`
                );
                return;
              }

              if (!canSetField(entry.wake, targetStamp, source === 'backfill', eventStamp)) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ä¸å…è®¸æŠŠ **Wake** æ”¹å¾—æ›´æ—©ã€‚\nå½“å‰ï¼š**${entry.wake || '(empty)'}**\nå°è¯•ï¼š**${targetStamp}**`
                );
                return;
              }

              entry.wake = targetStamp;
            }

            if (entry.source !== 'backfill') entry.source = source;
            computeDuration(entry);
            map.set(appliedDateKey, entry);

            // Write trusted event log comment (source of truth)
            const evt = {
              cmd: parsed.cmd === '/sleep' ? 'sleep' : 'wake',
              stamp: targetStamp,
              dateKey: appliedDateKey,
              source,
            };
            await comment(owner, repo, issue_number, buildEventComment(evt));

            // Rebuild again so table definitely reflects the new trusted event
            map = await applyRebuild();

            // Add BACKFILL_LABEL on issue if any backfill happened
            if (source === 'backfill') {
              const newLabels = Array.from(new Set([...(labels || []), BACKFILL_LABEL]));
              await github.rest.issues.update({
                owner,
                repo,
                issue_number,
                labels: newLabels,
              });
            }
