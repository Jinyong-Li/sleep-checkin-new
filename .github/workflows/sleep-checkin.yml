name: Sleep check-in

on:
  issue_comment:
    types: [created]

permissions:
  issues: write

concurrency:
  group: sleep-checkin-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  log:
    if: ${{ github.event.issue.pull_request == null }}
    runs-on: ubuntu-latest
    steps:
      - name: Handle /sleep /wake /rebuild /undo /archive
        uses: actions/github-script@v7
        with:
          script: |
            // ----------------------------
            // Config
            // ----------------------------
            const REQUIRED_LABEL = 'sleep-log';

            const BACKFILL_KEYWORD = 'backfill';
            const BACKFILL_MAX_DAYS = 7;

            const UNDO_MAX_MINUTES = 10;

            const RECENT_DAYS = 30;

            // archive hint threshold (trusted event comments only)
            const ARCHIVE_SUGGEST_THRESHOLD = 1500;
            const ARCHIVE_HINT_MARKER = '<!-- SLEEP_LOG_ARCHIVE_HINTED -->';

            // 04:00 (UTC+8): sleep before this hour counts as "previous night" (dateKey - 1 day)
            const CUTOFF_HOUR = 4;

            const TITLE_PREFIX = '[Sleep Log]';

            // Anti-tamper: only trust events emitted by github-actions[bot]
            const TRUSTED_EVENT_AUTHOR = 'github-actions[bot]';
            const EVENT_PREFIX = '<!--SLEEP_LOG_EVENT ';
            const EVENT_SUFFIX = '-->';

            // Cached state marker (written to issue body by bot)
            const STATE_PREFIX = '<!-- SLEEP_LOG_STATE ';
            const STATE_SUFFIX = ' -->';

            const ENFORCE_SINGLE_OPEN_ISSUE_PER_USER = true;

            // Strict local-time window enforcement (UTC+8)
            // - Wake allowed: 04:00 .. 20:00 (inclusive)
            // - Sleep allowed: 20:00 .. 04:00 (cross-midnight; 04:00 excluded, because 04:00 belongs to wake window)
            const STRICT_TIME_WINDOW = true;
            const WAKE_START_HHMM = '04:00';
            const WAKE_END_HHMM = '20:00';
            const SLEEP_START_HHMM = '20:00';
            const SLEEP_END_HHMM = '04:00';

            // Admin-only maintenance command
            // /admin-clear YYYY-MM-DD (sleep|wake) [note...]
            // note will be shown to users and recorded in the trusted event log (trimmed).
            const ADMIN_CLEAR_ALLOWED_USERS = new Set(['Jinyong-Li']);
            const ADMIN_CLEAR_NOTE_MAX_LEN = 200;

            // ----------------------------
            // Helpers: date/time
            // ----------------------------
            const pad = (n) => String(n).padStart(2, '0');

            function toUtc8Date(dateUtcIso) {
              const dt = new Date(dateUtcIso); // UTC
              return new Date(dt.getTime() + 8 * 60 * 60 * 1000);
            }

            function fmtUtc8Stamp(dateObjUtc8) {
              const yyyy = dateObjUtc8.getUTCFullYear();
              const mm = pad(dateObjUtc8.getUTCMonth() + 1);
              const dd = pad(dateObjUtc8.getUTCDate());
              const HH = pad(dateObjUtc8.getUTCHours());
              const MM = pad(dateObjUtc8.getUTCMinutes());
              return `${yyyy}-${mm}-${dd} ${HH}:${MM}`;
            }

            function fmtUtc8DateKey(dateObjUtc8) {
              const yyyy = dateObjUtc8.getUTCFullYear();
              const mm = pad(dateObjUtc8.getUTCMonth() + 1);
              const dd = pad(dateObjUtc8.getUTCDate());
              return `${yyyy}-${mm}-${dd}`;
            }

            function addDaysToUtc8DateKey(dateKey, deltaDays) {
              const m = dateKey.match(/^(\d{4})-(\d{2})-(\d{2})$/);
              if (!m) return null;

              const [, Y, M, D] = m;

              // UTC+8 midnight -> UTC time = midnight - 8h
              const utcMs = Date.UTC(Number(Y), Number(M) - 1, Number(D), -8, 0, 0);
              const newUtcMs = utcMs + deltaDays * 24 * 60 * 60 * 1000;
              const newUtc8 = new Date(newUtcMs + 8 * 60 * 60 * 1000);
              return fmtUtc8DateKey(newUtc8);
            }

            function minutesBetweenUtc8Stamps(sleepStamp, wakeStamp) {
              const m1 = sleepStamp.match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})$/);
              const m2 = wakeStamp.match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})$/);
              if (!m1 || !m2) return null;

              const [, Y1, M1, D1, h1, mi1] = m1;
              const [, Y2, M2, D2, h2, mi2] = m2;

              const t1 = Date.UTC(Number(Y1), Number(M1) - 1, Number(D1), Number(h1) - 8, Number(mi1));
              const t2 = Date.UTC(Number(Y2), Number(M2) - 1, Number(D2), Number(h2) - 8, Number(mi2));
              return Math.round((t2 - t1) / 60000);
            }

            function dateKeyForSleepEvent(utc8DateObj) {
              const hour = utc8DateObj.getUTCHours();
              const todayKey = fmtUtc8DateKey(utc8DateObj);
              if (hour < CUTOFF_HOUR) return addDaysToUtc8DateKey(todayKey, -1);
              return todayKey;
            }

            function parseHHMMFromStamp(stamp) {
              // stamp: YYYY-MM-DD HH:MM
              const m = String(stamp || '').match(/^\d{4}-\d{2}-\d{2} (\d{2}):(\d{2})$/);
              if (!m) return null;
              const hh = Number(m[1]);
              const mm = Number(m[2]);
              if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
              if (hh < 0 || hh > 23 || mm < 0 || mm > 59) return null;
              return { hh, mm };
            }

            function hhmmToMinutes(hhmm) {
              const m = String(hhmm || '').match(/^(\d{2}):(\d{2})$/);
              if (!m) return null;
              const hh = Number(m[1]);
              const mm = Number(m[2]);
              if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
              if (hh < 0 || hh > 23 || mm < 0 || mm > 59) return null;
              return hh * 60 + mm;
            }

            function isWithinWindowNonCross(min, startMin, endMinInclusive) {
              // [start, end] inclusive, no cross-midnight
              return min >= startMin && min <= endMinInclusive;
            }

            function isWithinWindowCross(min, startMin, endMinExclusive) {
              // cross-midnight window: [start, 24h) U [0, end)
              // end is exclusive to allow "04:00 belongs to wake".
              return min >= startMin || min < endMinExclusive;
            }

            function validateStrictTimeWindow(cmdWithSlash, stamp) {
              if (!STRICT_TIME_WINDOW) return { ok: true };

              const t = parseHHMMFromStamp(stamp);
              if (!t) return { ok: true };
              const min = t.hh * 60 + t.mm;

              const wakeStart = hhmmToMinutes(WAKE_START_HHMM);
              const wakeEnd = hhmmToMinutes(WAKE_END_HHMM);
              const sleepStart = hhmmToMinutes(SLEEP_START_HHMM);
              const sleepEnd = hhmmToMinutes(SLEEP_END_HHMM);

              if (wakeStart == null || wakeEnd == null || sleepStart == null || sleepEnd == null) return { ok: true };

              if (cmdWithSlash === '/wake') {
                const ok = isWithinWindowNonCross(min, wakeStart, wakeEnd);
                if (!ok) {
                  return {
                    ok: false,
                    message:
                      `⚠️ Wake 时间不在允许范围（北京时间 ${WAKE_START_HHMM}–${WAKE_END_HHMM}），本次命令已忽略。\n` +
                      `你输入：**${stamp}**`,
                  };
                }
                return { ok: true };
              }

              if (cmdWithSlash === '/sleep') {
                const ok = isWithinWindowCross(min, sleepStart, sleepEnd);
                if (!ok) {
                  return {
                    ok: false,
                    message:
                      `⚠️ Sleep 时间不在允许范围（北京时间 ${SLEEP_START_HHMM}–次日 ${SLEEP_END_HHMM}），本次命令已忽略。\n` +
                      `你输入：**${stamp}**`,
                  };
                }
                return { ok: true };
              }

              return { ok: true };
            }

            // ----------------------------
            // Helpers: table & state markers
            // ----------------------------
            function ensureTableBlock(issueBody) {
              const startMark = '<!-- SLEEP_LOG_TABLE_START -->';
              const endMark = '<!-- SLEEP_LOG_TABLE_END -->';

              let body = issueBody || '';
              if (!body.includes(startMark) || !body.includes(endMark)) {
                body =
                  `${body}\n\n${startMark}\n\n` +
                  `${endMark}\n`;
              }
              return { body, startMark, endMark };
            }

            function extractTable(body, startMark, endMark) {
              const startIdx = body.indexOf(startMark);
              const endIdx = body.indexOf(endMark);
              const before = body.slice(0, startIdx + startMark.length);
              const middle = body.slice(startIdx + startMark.length, endIdx);
              const after = body.slice(endIdx);
              return { before, middle, after };
            }

            function computeDuration(entry) {
              entry.duration = '';
              if (entry.sleep && entry.wake) {
                const diffMin = minutesBetweenUtc8Stamps(entry.sleep, entry.wake);
                if (diffMin != null && diffMin >= 0 && diffMin <= 24 * 60) {
                  const h = Math.floor(diffMin / 60);
                  const m = diffMin % 60;
                  entry.duration = `${h}h${pad(m)}m`;
                }
              }
            }

            function normalizeEntry(e) {
              const entry = {
                sleep: e?.sleep || '',
                wake: e?.wake || '',
                duration: e?.duration || '',
                source: e?.source || '',
              };
              computeDuration(entry);
              return entry;
            }

            function sortedDateKeysDesc(keys) {
              return [...keys].sort((a, b) => (a < b ? 1 : -1));
            }

            function buildRowsObjectToMap(rowsObj) {
              const map = new Map();
              for (const [k, v] of Object.entries(rowsObj || {})) {
                map.set(k, normalizeEntry(v));
              }
              return map;
            }

            function buildMapToRowsObject(map) {
              const rows = {};
              for (const [k, v] of map.entries()) {
                rows[k] = {
                  sleep: v.sleep || '',
                  wake: v.wake || '',
                  duration: v.duration || '',
                  source: v.source || '',
                };
              }
              return rows;
            }

            function buildTableMarkdownFromMap(map, keysDesc) {
              const out = [
                '| Date | Sleep (UTC+8) | Wake (UTC+8) | Duration | Source |',
                '|---|---|---|---|---|',
              ];

              for (const k of keysDesc) {
                const e = map.get(k) || { sleep: '', wake: '', duration: '', source: '' };
                out.push(`| ${k} | ${e.sleep || ''} | ${e.wake || ''} | ${e.duration || ''} | ${e.source || ''} |`);
              }

              return out.join('\n');
            }

            function buildTableMiddle(map, todayKey) {
              const allKeys = sortedDateKeysDesc(Array.from(map.keys()));
              const minRecent = addDaysToUtc8DateKey(todayKey, -(RECENT_DAYS - 1));
              const recentKeys = allKeys.filter((k) => !minRecent || (k >= minRecent && k <= todayKey));

              const recentTable = buildTableMarkdownFromMap(map, recentKeys);
              const allTable = buildTableMarkdownFromMap(map, allKeys);

              return (
                `\n\n` +
                `### Recent (last ${RECENT_DAYS} days)\n\n` +
                `${recentTable}\n\n` +
                `<details>\n` +
                `<summary>All history</summary>\n\n` +
                `${allTable}\n\n` +
                `</details>\n\n`
              );
            }

            function parseStateFromBody(body) {
              const start = (body || '').indexOf(STATE_PREFIX);
              if (start < 0) return null;
              const jsonStart = start + STATE_PREFIX.length;
              const end = (body || '').indexOf(STATE_SUFFIX, jsonStart);
              if (end < 0) return null;
              const jsonText = (body || '').slice(jsonStart, end).trim();
              try {
                const st = JSON.parse(jsonText);
                if (!st || typeof st !== 'object') return null;
                if (typeof st.cursor !== 'number') return null;
                if (!st.rows || typeof st.rows !== 'object') return null;
                return st;
              } catch {
                return null;
              }
            }

            function upsertStateIntoBody(body, stateObj) {
              const json = JSON.stringify(stateObj);
              const marker = `${STATE_PREFIX}${json}${STATE_SUFFIX}`;

              const start = (body || '').indexOf(STATE_PREFIX);
              if (start < 0) {
                return `${body || ''}\n\n${marker}\n`;
              }

              const jsonStart = start + STATE_PREFIX.length;
              const end = (body || '').indexOf(STATE_SUFFIX, jsonStart);
              if (end < 0) {
                return `${(body || '').slice(0, start).trimEnd()}\n\n${marker}\n`;
              }

              return (body || '').slice(0, start) + marker + (body || '').slice(end + STATE_SUFFIX.length);
            }

            function upsertArchiveHintMarker(body) {
              if ((body || '').includes(ARCHIVE_HINT_MARKER)) return body || '';
              return `${body || ''}\n\n${ARCHIVE_HINT_MARKER}\n`;
            }

            function issueLooksLikeSleepLog(issueBody) {
              const b = String(issueBody || '');
              return b.includes('<!-- SLEEP_LOG_ENABLED -->') || b.includes('<!-- SLEEP_LOG_TABLE_START -->');
            }

            // ----------------------------
            // Helpers: commands & events
            // ----------------------------
            function parseCommand(text) {
              // Supported commands:
              // - /sleep
              // - /wake
              // - /sleep YYYY-MM-DD HH:MM backfill
              // - /wake  YYYY-MM-DD HH:MM backfill
              // - /rebuild
              // - /undo
              // - /archive
              // - /admin-clear YYYY-MM-DD (sleep|wake) [note...]
              //   (admin-only; used to clean up buggy/wrong records; note is for human reading only)
              const parts = (text || '').trim().split(/\s+/).filter(Boolean);
              const cmd = (parts[0] || '').toLowerCase();

              if (cmd === '/rebuild') return { cmd };
              if (cmd === '/undo') return { cmd };
              if (cmd === '/archive') return { cmd };

              if (cmd === '/admin-clear') {
                const date = parts[1] || '';
                const field = (parts[2] || '').toLowerCase();
                const rawNote = parts.slice(3).join(' ');
                const note = rawNote.length > ADMIN_CLEAR_NOTE_MAX_LEN ? rawNote.slice(0, ADMIN_CLEAR_NOTE_MAX_LEN) : rawNote;
                if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) return null;
                if (!['sleep', 'wake'].includes(field)) return null;
                return { cmd, clearDate: date, clearField: field, clearNote: note };
              }

              if (cmd !== '/sleep' && cmd !== '/wake') return null;

              let explicitDate = null;
              let explicitTime = null;
              let isBackfill = false;

              if (parts.length === 2) {
                if (/^\d{2}:\d{2}$/.test(parts[1])) {
                  explicitTime = parts[1];
                }
              } else if (parts.length >= 3) {
                if (/^\d{4}-\d{2}-\d{2}$/.test(parts[1]) && /^\d{2}:\d{2}$/.test(parts[2])) {
                  explicitDate = parts[1];
                  explicitTime = parts[2];
                  isBackfill = parts.slice(3).map((s) => s.toLowerCase()).includes(BACKFILL_KEYWORD);
                }
              }

              return { cmd, explicitDate, explicitTime, isBackfill };
            }

            function parseEventFromCommentBody(body) {
              if (!body) return null;
              const start = body.indexOf(EVENT_PREFIX);
              if (start < 0) return null;

              const jsonStart = start + EVENT_PREFIX.length;
              const end = body.indexOf(EVENT_SUFFIX, jsonStart);
              if (end < 0) return null;

              const jsonText = body.slice(jsonStart, end).trim();
              try {
                const evt = JSON.parse(jsonText);
                if (!evt || typeof evt !== 'object') return null;

                if (!['sleep', 'wake', 'undo', 'clear'].includes(evt.cmd)) return null;
                if (typeof evt.id !== 'number') return null;

                if (evt.cmd === 'undo') {
                  if (typeof evt.revokes !== 'number') return null;
                  evt.source = evt.source || 'live';
                  return evt;
                }

                if (evt.cmd === 'clear') {
                  if (!evt.dateKey || !/^\d{4}-\d{2}-\d{2}$/.test(evt.dateKey)) return null;
                  if (!evt.field || !['sleep', 'wake'].includes(evt.field)) return null;
                  if (typeof evt.by !== 'string' || !evt.by) return null;
                  evt.source = evt.source || 'admin';
                  evt.note = String(evt.note || '');
                  evt.prev = String(evt.prev || '');
                  return evt;
                }

                if (!evt.stamp || !evt.dateKey) return null;
                if (!/^\d{4}-\d{2}-\d{2}$/.test(evt.dateKey)) return null;
                if (!/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/.test(evt.stamp)) return null;
                evt.source = evt.source || 'live';
                return evt;
              } catch {
                return null;
              }
            }

            async function createComment(owner, repo, issue_number, body) {
              const res = await github.rest.issues.createComment({ owner, repo, issue_number, body });
              return res.data;
            }

            async function updateComment(owner, repo, comment_id, body) {
              await github.rest.issues.updateComment({ owner, repo, comment_id, body });
            }

            function buildEventComment(evt) {
              if (evt.cmd === 'undo') {
                return (
                  `Recorded **Undo**: revoked event **${evt.revokes}**\n` +
                  `${EVENT_PREFIX}${JSON.stringify(evt)} ${EVENT_SUFFIX}`
                );
              }

              if (evt.cmd === 'clear') {
                const noteLine = evt.note ? `\nReason: ${evt.note}` : '';
                return (
                  `Recorded **Admin Clear** (${evt.field}): **${evt.dateKey}**` +
                  (evt.prev ? ` (prev: **${evt.prev}**)` : '') +
                  noteLine +
                  `\n${EVENT_PREFIX}${JSON.stringify(evt)} ${EVENT_SUFFIX}`
                );
              }

              const action = evt.cmd === 'sleep' ? 'Sleep' : 'Wake';
              const extra = evt.source === 'backfill' ? ' (backfill)' : '';
              return (
                `Recorded **${action}**${extra}: **${evt.stamp} (UTC+8)**\n` +
                  `${EVENT_PREFIX}${JSON.stringify(evt)} ${EVENT_SUFFIX}`
              );
            }

            async function listCommentsPage(owner, repo, issue_number, page, per_page = 100) {
              const res = await github.rest.issues.listComments({ owner, repo, issue_number, per_page, page });
              return res.data || [];
            }

            async function listAllComments(owner, repo, issue_number) {
              const per_page = 100;
              let page = 1;
              const all = [];
              while (true) {
                const items = await listCommentsPage(owner, repo, issue_number, page, per_page);
                all.push(...items);
                if (items.length < per_page) break;
                page += 1;
              }
              return all;
            }

            async function buildTrustedEventsFull(owner, repo, issue_number) {
              const comments = await listAllComments(owner, repo, issue_number);

              const events = [];
              for (const c of comments) {
                if (c.user?.login !== TRUSTED_EVENT_AUTHOR) continue;
                const evt = parseEventFromCommentBody(c.body || '');
                if (!evt) continue;
                if (evt.id !== c.id) continue;
                evt._comment_created_at = c.created_at;
                events.push(evt);
              }

              events.sort((a, b) => (a._comment_created_at < b._comment_created_at ? -1 : 1));
              return events;
            }

            function buildMapFromEvents(events) {
              const revoked = new Set();
              for (const evt of events) {
                if (evt.cmd === 'undo') revoked.add(evt.revokes);
              }

              const map = new Map();

              for (const evt of events) {
                if (evt.cmd === 'undo') continue;
                if (revoked.has(evt.id)) continue;

                const e = map.get(evt.dateKey) || { sleep: '', wake: '', duration: '', source: '' };

                if (evt.cmd === 'clear') {
                  if (evt.field === 'sleep') e.sleep = '';
                  if (evt.field === 'wake') e.wake = '';
                  // DO NOT change e.source here (so future live records won't be "polluted" as backfill)
                  computeDuration(e);
                  map.set(evt.dateKey, e);
                  continue;
                }

                if (evt.cmd === 'sleep') {
                  if (!e.sleep || evt.stamp >= e.sleep) e.sleep = evt.stamp;
                } else {
                  if (!e.wake || evt.stamp >= e.wake) e.wake = evt.stamp;
                }

                if (e.source !== 'backfill') e.source = evt.source || 'live';
                computeDuration(e);
                map.set(evt.dateKey, e);
              }

              const cursor = events.length ? Math.max(...events.map((e) => e.id)) : 0;
              return { map, cursor };
            }

            function canSetField(oldStamp, newFullStamp, isBackfill, eventStamp) {
              if (oldStamp) return newFullStamp >= oldStamp;
              if (!isBackfill) return newFullStamp >= eventStamp;
              return true;
            }

            async function findOtherOpenSleepLogIssueUrl(owner, repo, issueAuthor, currentIssueNumber) {
              const per_page = 100;
              let page = 1;

              while (true) {
                const res = await github.rest.issues.listForRepo({
                  owner,
                  repo,
                  state: 'open',
                  labels: REQUIRED_LABEL,
                  per_page,
                  page,
                });

                const items = res.data || [];
                for (const it of items) {
                  if (it.pull_request) continue;
                  if (it.user?.login !== issueAuthor) continue;
                  if (it.number === currentIssueNumber) continue;
                  return it.html_url;
                }

                if (items.length < per_page) break;
                page += 1;
              }

              return null;
            }

            function getDateRangeFromMap(map) {
              const keys = Array.from(map.keys()).sort(); // asc
              if (!keys.length) return null;
              return { start: keys[0], end: keys[keys.length - 1] };
            }

            // ----------------------------
            // Start
            // ----------------------------
            const parsed = parseCommand(context.payload.comment.body);
            if (!parsed) return;

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.issue.number;

            const issueRes = await github.rest.issues.get({ owner, repo, issue_number });
            const issue = issueRes.data;

            const commenter = context.payload.comment.user.login;
            const issueAuthor = issue.user?.login;

            // ----------------------------
            // Permission
            // ----------------------------
            // Normal commands: only issue author
            // Admin command /admin-clear: only ADMIN_CLEAR_ALLOWED_USERS
            if (parsed.cmd === '/admin-clear') {
              if (!ADMIN_CLEAR_ALLOWED_USERS.has(commenter)) return;

              if (!issueLooksLikeSleepLog(issue.body || '')) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `⚠️ 该 issue 不是 sleep-log 模板（缺少 SLEEP_LOG 标记），拒绝执行 /admin-clear。\n` +
                    `如果你确认需要修复，请在正确的 Sleep Log issue 上执行。`
                );
                return;
              }
            } else {
              if (!issueAuthor || commenter !== issueAuthor) return;
            }

            // Title normalize (for active log)
            if (issueAuthor) {
              const desiredTitleActive = `${TITLE_PREFIX} @${issueAuthor}`;
              if (!issue.title?.includes(`@${issueAuthor}`) && !issue.title?.includes('[archived]')) {
                await github.rest.issues.update({ owner, repo, issue_number, title: desiredTitleActive });
              }
            }

            // label list
            let labels = (issue.labels || []).map((l) => (typeof l === 'string' ? l : l.name)).filter(Boolean);

            // Single-open-issue policy
            const enforceSingleIssue = async () => {
              if (!ENFORCE_SINGLE_OPEN_ISSUE_PER_USER) return true;
              if (!issueAuthor) return true;

              const otherUrl = await findOtherOpenSleepLogIssueUrl(owner, repo, issueAuthor, issue_number);
              if (!otherUrl) return true;

              await createComment(
                owner,
                repo,
                issue_number,
                `⚠️ 为了避免记录分散，你只能拥有 **一个** 处于 open 状态的 sleep-log issue。\n` +
                  `请到这个 issue 继续记录：${otherUrl}\n\n` +
                  `接下来你可以：\n` +
                  `1) 关闭当前这个 issue；\n` +
                  `2) 到上面链接的 issue 里继续记录；\n` +
                  `3) 如果那个 issue 被误关了，reopen 后即可继续使用。`
              );
              return false;
            };

            // Enable label on first use when marker exists (only meaningful for normal flow)
            if (parsed.cmd !== '/admin-clear' && !labels.includes(REQUIRED_LABEL)) {
              const issueBody = issue.body || '';
              const hasMarker = issueBody.includes('<!-- SLEEP_LOG_ENABLED -->');
              if (!hasMarker) return;

              const ok = await enforceSingleIssue();
              if (!ok) return;

              await github.rest.issues.addLabels({ owner, repo, issue_number, labels: [REQUIRED_LABEL] });
              labels.push(REQUIRED_LABEL);

              await createComment(owner, repo, issue_number, `✅ 已自动启用 sleep-log 功能。`);
            }

            // Always enforce for every normal command
            if (parsed.cmd !== '/admin-clear') {
              const okSingle = await enforceSingleIssue();
              if (!okSingle) return;
            }

            // Event time (UTC+8)
            const eventUtc8 = toUtc8Date(context.payload.comment.created_at);
            const eventStamp = fmtUtc8Stamp(eventUtc8);
            const eventDateKey = fmtUtc8DateKey(eventUtc8);

            // Load latest issue body (for state/table updates)
            const latestIssueRes = await github.rest.issues.get({ owner, repo, issue_number });
            const latestIssue = latestIssueRes.data;
            const ensured = ensureTableBlock(latestIssue.body || '');
            const state = parseStateFromBody(ensured.body);

            // Decide mode
            const forceFullRebuild =
              parsed.cmd === '/rebuild' || parsed.cmd === '/undo' || parsed.cmd === '/archive' || parsed.cmd === '/admin-clear' || !state;

            // Build working map
            let map = new Map();
            let cursor = 0;

            async function writeBodyWithTableAndState(mapToWrite, cursorToWrite, noteIfNoEvents) {
              const latest2 = await github.rest.issues.get({ owner, repo, issue_number });
              const ensured2 = ensureTableBlock(latest2.data.body || '');
              const { before, after } = extractTable(ensured2.body, ensured2.startMark, ensured2.endMark);

              if (mapToWrite.size === 0) {
                let bodyKeep = ensured2.body;
                const st = { cursor: cursorToWrite || 0, rows: {} };
                bodyKeep = upsertStateIntoBody(bodyKeep, st);

                if ((latest2.data.body || '') !== bodyKeep) {
                  await github.rest.issues.update({ owner, repo, issue_number, body: bodyKeep });
                }

                if (noteIfNoEvents) {
                  await createComment(
                    owner,
                    repo,
                    issue_number,
                    `ℹ️ 当前未检测到可信事件日志（SLEEP_LOG_EVENT），已保持现有表格不变。\n` +
                      `当首次成功记录后，表格将以事件日志为准自动重建（也可用 \`/rebuild\`）。`
                  );
                }
                return;
              }

              const middle = buildTableMiddle(mapToWrite, eventDateKey);
              let finalBody = before + middle + after;

              const stateObj = { cursor: cursorToWrite || 0, rows: buildMapToRowsObject(mapToWrite) };
              finalBody = upsertStateIntoBody(finalBody, stateObj);

              await github.rest.issues.update({ owner, repo, issue_number, body: finalBody });
            }

            async function fullRebuildAndWrite({ commentOnNoEvents } = { commentOnNoEvents: false }) {
              const events = await buildTrustedEventsFull(owner, repo, issue_number);
              const rebuilt = buildMapFromEvents(events);
              map = rebuilt.map;
              cursor = rebuilt.cursor;

              await writeBodyWithTableAndState(map, cursor, commentOnNoEvents && map.size === 0);

              if (!ensured.body.includes(ARCHIVE_HINT_MARKER) && events.length >= ARCHIVE_SUGGEST_THRESHOLD) {
                const body3 = upsertArchiveHintMarker((await github.rest.issues.get({ owner, repo, issue_number })).data.body || '');
                await github.rest.issues.update({ owner, repo, issue_number, body: body3 });
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `ℹ️ 该日志的可信事件评论数已达到 **${events.length}**（>= ${ARCHIVE_SUGGEST_THRESHOLD}）。\n` +
                    `如果你想让 issue 更“轻”，可以使用 \`/archive\` 自动封存并关闭此 issue，然后新建一个新的 Sleep Log issue 继续记录。`
                );
              }

              return { map, cursor, trustedEventsCount: events.length, events };
            }

            let fullEvents = null;

            if (forceFullRebuild) {
              const r = await fullRebuildAndWrite({ commentOnNoEvents: true });
              fullEvents = r.events;

              if (parsed.cmd === '/rebuild') {
                await createComment(owner, repo, issue_number, `✅ 已从事件日志重建表格。`);
                return;
              }
            } else {
              cursor = state.cursor;
              map = buildRowsObjectToMap(state.rows);
            }

            if (parsed.cmd === '/archive') {
              if (!labels.includes(REQUIRED_LABEL)) return;

              const range = getDateRangeFromMap(map);
              const rangeText = range ? `(${range.start} ~ ${range.end}) ` : '';
              const newTitle = `${TITLE_PREFIX} @${issueAuthor} ${rangeText}[archived]`;

              await github.rest.issues.update({ owner, repo, issue_number, title: newTitle });

              await createComment(
                owner,
                repo,
                issue_number,
                `✅ 已封存该日志并准备关闭。\n` +
                  `建议：使用模板新建一个新的 Sleep Log issue 继续记录（保持每人只有一个 open）。`
              );

              await github.rest.issues.update({ owner, repo, issue_number, state: 'closed' });
              return;
            }

            if (parsed.cmd === '/undo') {
              const events = fullEvents || (await buildTrustedEventsFull(owner, repo, issue_number));

              const revoked = new Set();
              for (const e of events) if (e.cmd === 'undo') revoked.add(e.revokes);

              const candidates = events
                .filter((e) => e.cmd === 'sleep' || e.cmd === 'wake' || e.cmd === 'clear')
                .filter((e) => !revoked.has(e.id))
                .sort((a, b) => (a._comment_created_at < b._comment_created_at ? 1 : -1));

              const target = candidates[0];
              if (!target) {
                await createComment(owner, repo, issue_number, `⚠️ 没有找到可撤销的记录（sleep/wake/admin-clear）。`);
                return;
              }

              const diffMin = Math.round((new Date(context.payload.comment.created_at).getTime() - new Date(target._comment_created_at).getTime()) / 60000);
              const targetUtc8 = toUtc8Date(target._comment_created_at);
              const targetStampUtc8 = fmtUtc8Stamp(targetUtc8);

              if (diffMin > UNDO_MAX_MINUTES) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `⚠️ 只能撤销最近 **${UNDO_MAX_MINUTES}** 分钟内的记录。\n` +
                    `最近一次记录时间：**${targetStampUtc8}**（UTC+8）\n` +
                    `距现在约：**${diffMin}** 分钟`
                );
                return;
              }

              const placeholder = await createComment(owner, repo, issue_number, `Recording undo...`);
              const undoEvt = { id: placeholder.id, cmd: 'undo', revokes: target.id, at: eventStamp, source: 'live' };
              await updateComment(owner, repo, placeholder.id, buildEventComment(undoEvt));

              await fullRebuildAndWrite({ commentOnNoEvents: false });

              await createComment(
                owner,
                repo,
                issue_number,
                `✅ 已撤销最近一次记录：**${target.cmd === 'clear' ? 'admin-clear' : target.cmd}**（事件 ID: ${target.id}）。`
              );
              return;
            }

            // Admin-only clear (no backfill keyword required; allow optional explanation note)
            if (parsed.cmd === '/admin-clear') {
              const appliedDateKey = parsed.clearDate;
              const field = parsed.clearField;

              const todayKey = eventDateKey;
              const minAllowed = addDaysToUtc8DateKey(todayKey, -BACKFILL_MAX_DAYS);

              if (minAllowed && (appliedDateKey < minAllowed || appliedDateKey > todayKey)) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `⚠️ Admin 清空仅允许最近 **${BACKFILL_MAX_DAYS}** 天（**${minAllowed}** ~ **${todayKey}**）。\n` +
                    `你尝试清空的日期：**${appliedDateKey}**`
                );
                return;
              }

              const entry = map.get(appliedDateKey) || { sleep: '', wake: '', duration: '', source: '' };
              const prev = field === 'sleep' ? entry.sleep : entry.wake;

              // If nothing to clear, avoid creating empty rows/noisy events
              if (!prev) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `ℹ️ ${appliedDateKey} 的 **${field}** 本来就是空的，无需清空。` +
                    (parsed.clearNote ? `\n说明：${parsed.clearNote}` : '')
                );
                return;
              }

              if (field === 'sleep') entry.sleep = '';
              if (field === 'wake') entry.wake = '';
              // DO NOT change entry.source here
              computeDuration(entry);
              map.set(appliedDateKey, entry);

              const placeholder = await createComment(owner, repo, issue_number, `Recording admin clear...`);
              const evt = {
                id: placeholder.id,
                cmd: 'clear',
                dateKey: appliedDateKey,
                field,
                prev: prev || '',
                by: commenter,
                note: parsed.clearNote || '',
                source: 'admin',
              };
              await updateComment(owner, repo, placeholder.id, buildEventComment(evt));

              cursor = Math.max(cursor || 0, placeholder.id);

              // write table + state
              const middle = buildTableMiddle(map, eventDateKey);
              const latest3 = await github.rest.issues.get({ owner, repo, issue_number });
              const ensured3 = ensureTableBlock(latest3.data.body || '');
              const { before, after } = extractTable(ensured3.body, ensured3.startMark, ensured3.endMark);

              let finalBody = before + middle + after;
              const stateObj = { cursor: cursor || 0, rows: buildMapToRowsObject(map) };
              finalBody = upsertStateIntoBody(finalBody, stateObj);

              await github.rest.issues.update({ owner, repo, issue_number, body: finalBody });

              await createComment(
                owner,
                repo,
                issue_number,
                `✅ 已清空 ${appliedDateKey} 的 **${field}** 字段。` + (parsed.clearNote ? `\n说明：${parsed.clearNote}` : '')
              );
              return;
            }

            const findLatestIncompleteDateKey = () => {
              const keys = Array.from(map.keys()).sort((a, b) => (a < b ? 1 : -1));
              for (const k of keys) {
                const e = map.get(k);
                if (e && e.sleep && !e.wake) return k;
              }
              return null;
            };

            let appliedDateKey = null;
            let targetStamp = null;
            let source = 'live';

            if (!parsed.explicitTime) {
              if (parsed.cmd === '/sleep') {
                appliedDateKey = dateKeyForSleepEvent(eventUtc8);
                targetStamp = eventStamp;
              } else {
                // Scheme A: forbid wake-only (no fallback to eventDateKey)
                const k = findLatestIncompleteDateKey();
                if (!k) {
                  await createComment(
                    owner,
                    repo,
                    issue_number,
                    `⚠️ 未找到“已记录 Sleep 但尚未记录 Wake”的条目，因此无法记录 Wake。\n` +
                      `请先发送 \`/sleep\`（记录入睡），然后再发送 \`/wake\`。\n` +
                      `如果你是补记，请使用：\`/wake YYYY-MM-DD HH:MM backfill\``
                  );
                  return;
                }
                appliedDateKey = k;
                targetStamp = eventStamp;
              }
            } else if (parsed.explicitTime && !parsed.explicitDate) {
              await createComment(
                owner,
                repo,
                issue_number,
                `⚠️ 不支持 \`${parsed.cmd} HH:MM\` 格式。\n` +
                  `请使用：\n` +
                  `- \`${parsed.cmd}\` 记录当前时间\n` +
                  `- \`${parsed.cmd} YYYY-MM-DD HH:MM backfill\` 补记/修正（仅允许最近 ${BACKFILL_MAX_DAYS} 天）`
              );
              return;
            } else if (parsed.explicitDate && parsed.explicitTime) {
              if (!parsed.isBackfill) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `⚠️ 指定日期和时间修改记录时，必须在命令末尾加上 \`backfill\` 关键字。\n` +
                    `正确格式：\`${parsed.cmd} ${parsed.explicitDate} ${parsed.explicitTime} backfill\``
                );
                return;
              }

              // BACKFILL: interpret the given YYYY-MM-DD as the *natural date* of the event,
              // then apply cutoff rule (04:00) to decide the *dateKey* for /sleep.
              const naturalDateKey = parsed.explicitDate;

              // Backfill window check should use the *natural date* (what user typed),
              // so that "/sleep 2026-01-08 01:20 backfill" is considered within the last N days.
              const todayKey = eventDateKey;
              const minAllowed = addDaysToUtc8DateKey(todayKey, -BACKFILL_MAX_DAYS);

              if (minAllowed && (naturalDateKey < minAllowed || naturalDateKey > todayKey)) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `⚠️ Backfill 仅允许最近 **${BACKFILL_MAX_DAYS}** 天（**${minAllowed}** ~ **${todayKey}**）。\n` +
                    `你尝试修改的日期：**${naturalDateKey}**`
                );
                return;
              }

              targetStamp = `${parsed.explicitDate} ${parsed.explicitTime}`;
              source = 'backfill';

              // Decide appliedDateKey with cutoff for /sleep only
              appliedDateKey = naturalDateKey;
              if (parsed.cmd === '/sleep') {
                const t = parseHHMMFromStamp(targetStamp);
                if (t) {
                  const minutes = t.hh * 60 + t.mm;
                  const cutoffMin = CUTOFF_HOUR * 60; // 04:00
                  if (minutes < cutoffMin) {
                    appliedDateKey = addDaysToUtc8DateKey(naturalDateKey, -1) || naturalDateKey;
                  }
                }
              }

              if (targetStamp > eventStamp) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `⚠️ Backfill 不能填写未来时间。\n` +
                    `你输入：**${targetStamp}**\n` +
                    `当前时间：**${eventStamp}**（UTC+8）`
                );
                return;
              }
            }

            if (!appliedDateKey || !targetStamp) return;

            // Strict time window enforcement (applies to both live and backfill)
            {
              const v = validateStrictTimeWindow(parsed.cmd, targetStamp);
              if (!v.ok) {
                await createComment(owner, repo, issue_number, v.message);
                return;
              }
            }

            const entry = map.get(appliedDateKey) || { sleep: '', wake: '', duration: '', source: '' };

            if (parsed.cmd === '/sleep') {
              if (entry.sleep && source !== 'backfill') {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `${appliedDateKey} 已经记录过 **Sleep**：**${entry.sleep}**。\n` +
                    `如需修正，请使用：\n` +
                    `\`/sleep ${appliedDateKey} HH:MM backfill\`\n` +
                    `（仅允许最近 ${BACKFILL_MAX_DAYS} 天，且只能把时间改得更晚；也可用 \`/undo\` 撤销最近一次误操作）`
                );
                return;
              }

              if (entry.wake && targetStamp >= entry.wake) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `❌ 不能把 **Sleep** 设为 **${targetStamp}**，因为它晚于或等于已记录的 **Wake**（**${entry.wake}**）。`
                );
                return;
              }

              if (!canSetField(entry.sleep, targetStamp, source === 'backfill', eventStamp)) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `⚠️ 不允许把 **Sleep** 改得更早。\n当前：**${entry.sleep || '(empty)'}**\n尝试：**${targetStamp}**`
                );
                return;
              }

              entry.sleep = targetStamp;
            } else {
              if (entry.wake && source !== 'backfill') {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `${appliedDateKey} 已经记录过 **Wake**：**${entry.wake}**。\n` +
                    `如需修正，请使用：\n` +
                    `\`/wake ${appliedDateKey} HH:MM backfill\`\n` +
                    `（仅允许最近 ${BACKFILL_MAX_DAYS} 天，且只能把时间改得更晚；也可用 \`/undo\` 撤销最近一次误操作）`
                );
                return;
              }

              if (entry.sleep && targetStamp <= entry.sleep) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `❌ 不能把 **Wake** 设为 **${targetStamp}**，因为它早于或等于已记录的 **Sleep**（**${entry.sleep}**）。`
                );
                return;
              }

              if (!canSetField(entry.wake, targetStamp, source === 'backfill', eventStamp)) {
                await createComment(
                  owner,
                  repo,
                  issue_number,
                  `⚠️ 不允许把 **Wake** 改得更早。\n当前：**${entry.wake || '(empty)'}**\n尝试：**${targetStamp}**`
                );
                return;
              }

              entry.wake = targetStamp;
            }

            if (entry.source !== 'backfill') entry.source = source;
            computeDuration(entry);
            map.set(appliedDateKey, entry);

            const placeholder = await createComment(owner, repo, issue_number, `Recording event...`);
            const evt = {
              id: placeholder.id,
              cmd: parsed.cmd === '/sleep' ? 'sleep' : 'wake',
              stamp: targetStamp,
              dateKey: appliedDateKey,
              source,
            };
            await updateComment(owner, repo, placeholder.id, buildEventComment(evt));

            cursor = Math.max(cursor || 0, placeholder.id);

            // write table + state
            const middle = buildTableMiddle(map, eventDateKey);
            const latest3 = await github.rest.issues.get({ owner, repo, issue_number });
            const ensured3 = ensureTableBlock(latest3.data.body || '');
            const { before, after } = extractTable(ensured3.body, ensured3.startMark, ensured3.endMark);

            let finalBody = before + middle + after;
            const stateObj = { cursor: cursor || 0, rows: buildMapToRowsObject(map) };
            finalBody = upsertStateIntoBody(finalBody, stateObj);

            await github.rest.issues.update({ owner, repo, issue_number, body: finalBody });

            // archive hint (fast path intentionally does nothing; full rebuild path handles thresholding)
            if (!(finalBody.includes(ARCHIVE_HINT_MARKER)) && cursor >= 1) {
              // no-op
            }
