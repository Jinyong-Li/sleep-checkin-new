name: Sleep check-in

on:
  issue_comment:
    types: [created]

permissions:
  issues: write

concurrency:
  group: sleep-checkin-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  log:
    if: ${{ github.event.issue.pull_request == null }}
    runs-on: ubuntu-latest
    steps:
      - name: Handle /sleep and /wake
        uses: actions/github-script@v7
        with:
          script: |
            // ----------------------------
            // Config
            // ----------------------------
            const REQUIRED_LABEL = 'sleep-log';

            const BACKFILL_LABEL = 'backfill';
            const BACKFILL_KEYWORD = 'backfill';
            const BACKFILL_MAX_DAYS = 7;

            // 04:00 (UTC+8): sleep before this hour counts as "previous night" (dateKey - 1 day)
            const CUTOFF_HOUR = 4;

            // ----------------------------
            // Helpers
            // ----------------------------
            const pad = (n) => String(n).padStart(2, '0');

            function toUtc8Date(dateUtcIso) {
              const dt = new Date(dateUtcIso); // UTC
              // UTC+8 wall time encoded in UTC getters
              return new Date(dt.getTime() + 8 * 60 * 60 * 1000);
            }

            function fmtUtc8Stamp(dateObjUtc8) {
              const yyyy = dateObjUtc8.getUTCFullYear();
              const mm = pad(dateObjUtc8.getUTCMonth() + 1);
              const dd = pad(dateObjUtc8.getUTCDate());
              const HH = pad(dateObjUtc8.getUTCHours());
              const MM = pad(dateObjUtc8.getUTCMinutes());
              return `${yyyy}-${mm}-${dd} ${HH}:${MM}`;
            }

            function fmtUtc8DateKey(dateObjUtc8) {
              const yyyy = dateObjUtc8.getUTCFullYear();
              const mm = pad(dateObjUtc8.getUTCMonth() + 1);
              const dd = pad(dateObjUtc8.getUTCDate());
              return `${yyyy}-${mm}-${dd}`;
            }

            function addDaysToUtc8DateKey(dateKey, deltaDays) {
              // dateKey is YYYY-MM-DD in UTC+8 wall date
              const m = dateKey.match(/^(\d{4})-(\d{2})-(\d{2})$/);
              if (!m) return null;

              const [, Y, M, D] = m;

              // interpret as UTC+8 midnight -> UTC time = (midnight - 8h)
              const utcMs = Date.UTC(Number(Y), Number(M) - 1, Number(D), -8, 0, 0);
              const newUtcMs = utcMs + deltaDays * 24 * 60 * 60 * 1000;
              const newUtc8 = new Date(newUtcMs + 8 * 60 * 60 * 1000);
              return fmtUtc8DateKey(newUtc8);
            }

            function minutesBetweenUtc8Stamps(sleepStamp, wakeStamp) {
              // stamps are "YYYY-MM-DD HH:MM" in UTC+8 wall time
              const m1 = sleepStamp.match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})$/);
              const m2 = wakeStamp.match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})$/);
              if (!m1 || !m2) return null;

              const [, Y1, M1, D1, h1, mi1] = m1;
              const [, Y2, M2, D2, h2, mi2] = m2;

              const t1 = Date.UTC(Number(Y1), Number(M1) - 1, Number(D1), Number(h1) - 8, Number(mi1));
              const t2 = Date.UTC(Number(Y2), Number(M2) - 1, Number(D2), Number(h2) - 8, Number(mi2));
              return Math.round((t2 - t1) / 60000);
            }

            function ensureTableBlock(issueBody) {
              const startMark = '<!-- SLEEP_LOG_TABLE_START -->';
              const endMark = '<!-- SLEEP_LOG_TABLE_END -->';

              let body = issueBody || '';
              if (!body.includes(startMark) || !body.includes(endMark)) {
                body =
                  `${body}\n\n${startMark}\n\n` +
                  `| Date | Sleep (UTC+8) | Wake (UTC+8) | Duration | Source |\n` +
                  `|---|---|---|---|---|\n\n` +
                  `${endMark}\n`;
              }
              return { body, startMark, endMark };
            }

            function extractTable(body, startMark, endMark) {
              const startIdx = body.indexOf(startMark);
              const endIdx = body.indexOf(endMark);
              const before = body.slice(0, startIdx + startMark.length);
              const middle = body.slice(startIdx + startMark.length, endIdx);
              const after = body.slice(endIdx);
              return { before, middle, after };
            }

            function parseTableToMap(middle) {
              // returns Map<dateKey, {sleep,wake,duration,source}>
              const lines = middle.split('\n').map((l) => l.trimEnd());
              const headerIdx = lines.findIndex((l) => l.startsWith('| Date |'));

              let tableLines = [];
              if (headerIdx >= 0) {
                tableLines = lines.slice(headerIdx).filter((l) => l.trim() !== '');
              } else {
                tableLines = [
                  '| Date | Sleep (UTC+8) | Wake (UTC+8) | Duration | Source |',
                  '|---|---|---|---|---|',
                ];
              }

              const rows = tableLines.slice(2); // è·³è¿‡è¡¨å¤´å’Œåˆ†éš”è¡Œ
              const map = new Map();

              for (const r of rows) {
                if (!r.startsWith('|')) continue;

                const parts = r.split('|').map((s) => s.trim());
                // Markdown è¡¨æ ¼è¡Œæ ¼å¼ï¼š'| col1 | col2 | col3 | col4 | col5 |'
                // split åï¼š['', 'col1', 'col2', 'col3', 'col4', 'col5', '']
                if (parts.length < 6) continue;

                const date = parts[1];
                const sleep = parts[2] || '';
                const wake = parts[3] || '';
                const duration = parts[4] || '';
                const source = parts[5] || '';

                if (date) {
                  map.set(date, { sleep, wake, duration, source });
                }
              }

              return map;
            }

            function rebuildMiddleFromMap(map) {
              const keys = Array.from(map.keys()).sort((a, b) => (a < b ? 1 : -1)); // desc
              const out = [
                '| Date | Sleep (UTC+8) | Wake (UTC+8) | Duration | Source |',
                '|---|---|---|---|---|',
                ...keys.map((k) => {
                  const e = map.get(k);
                  return `| ${k} | ${e.sleep || ''} | ${e.wake || ''} | ${e.duration || ''} | ${e.source || ''} |`;
                }),
              ];
              return `\n\n${out.join('\n')}\n\n`;
            }

            function computeDuration(entry) {
              entry.duration = ''; // é»˜è®¤æ¸…ç©º

              if (entry.sleep && entry.wake) {
                const diffMin = minutesBetweenUtc8Stamps(entry.sleep, entry.wake);

                // åªæœ‰åœ¨ diffMin æœ‰æ•ˆä¸” >= 0 ä¸” <= 24h æ—¶æ‰è®¡ç®—
                if (diffMin != null && diffMin >= 0 && diffMin <= 24 * 60) {
                  const h = Math.floor(diffMin / 60);
                  const m = diffMin % 60;
                  entry.duration = `${h}h${pad(m)}m`;
                } else {
                  // wake < sleep æˆ–è¶…è¿‡ 24hï¼Œduration ä¿æŒä¸ºç©º
                  entry.duration = '';
                }
              }
            }

            function dateKeyForSleepEvent(utc8DateObj) {
              // If sleep occurs before cutoff hour, count it as previous day
              const hour = utc8DateObj.getUTCHours();
              const todayKey = fmtUtc8DateKey(utc8DateObj);

              if (hour < CUTOFF_HOUR) {
                return addDaysToUtc8DateKey(todayKey, -1);
              }
              return todayKey;
            }

            function parseCommand(text) {
              // Supported:
              // /sleep
              // /wake
              // /sleep YYYY-MM-DD HH:MM backfill
              // /wake  YYYY-MM-DD HH:MM backfill
              const parts = (text || '').trim().split(/\s+/).filter(Boolean);
              const cmd = (parts[0] || '').toLowerCase();
              if (cmd !== '/sleep' && cmd !== '/wake') return null;

              let explicitDate = null;
              let explicitTime = null;
              let isBackfill = false;

              if (parts.length === 2) {
                // Disallow "/sleep HH:MM" and "/wake HH:MM"
                if (/^\d{2}:\d{2}$/.test(parts[1])) {
                  explicitTime = parts[1];
                }
              } else if (parts.length >= 3) {
                if (/^\d{4}-\d{2}-\d{2}$/.test(parts[1]) && /^\d{2}:\d{2}$/.test(parts[2])) {
                  explicitDate = parts[1];
                  explicitTime = parts[2];
                  isBackfill = parts
                    .slice(3)
                    .map((s) => s.toLowerCase())
                    .includes(BACKFILL_KEYWORD);
                }
              }

              return { cmd, explicitDate, explicitTime, isBackfill };
            }

            async function comment(owner, repo, issue_number, body) {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }

            // Strategy B core rule:
            // - If already has value: only allow update when new >= old (never earlier)
            // - If empty and not backfill: new must be >= eventStamp (can't set earlier than "now")
            function canSetField(oldStamp, newFullStamp, isBackfill, eventStamp) {
              if (oldStamp) return newFullStamp >= oldStamp;
              if (!isBackfill) return newFullStamp >= eventStamp;
              return true;
            }

            // ----------------------------
            // Start
            // ----------------------------
            const parsed = parseCommand(context.payload.comment.body);
            if (!parsed) return;

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.issue.number;

            // Read issue
            const issueRes = await github.rest.issues.get({ owner, repo, issue_number });
            const issue = issueRes.data;

            const commenter = context.payload.comment.user.login;
            const issueAuthor = issue.user?.login;

            // Only allow issue author
            if (!issueAuthor || commenter !== issueAuthor) return;

            // Must have required label (or auto-add it)
            let labels = (issue.labels || [])
              .map((l) => (typeof l === 'string' ? l : l.name))
              .filter(Boolean);

            if (!labels.includes(REQUIRED_LABEL)) {
              // Check if issue body has the enable marker
              const issueBody = issue.body || '';
              const hasMarker = issueBody.includes('<!-- SLEEP_LOG_ENABLED -->');

              // Only allow issue author to auto-enable
              if (hasMarker) {
                // Auto-add label
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number,
                  labels: [REQUIRED_LABEL],
                });
                labels.push(REQUIRED_LABEL); // update local array

                await comment(owner, repo, issue_number, `@${commenter} âœ… å·²è‡ªåŠ¨å¯ç”¨ sleep-log åŠŸèƒ½ã€‚`);
              } else {
                // Not enabled, ignore
                return;
              }
            }

            // Event time (UTC+8)
            const eventUtc8 = toUtc8Date(context.payload.comment.created_at);
            const eventStamp = fmtUtc8Stamp(eventUtc8);
            const eventDateKey = fmtUtc8DateKey(eventUtc8);

            // Determine base table
            const { body: ensuredBody, startMark, endMark } = ensureTableBlock(issue.body || '');
            const { before, middle, after } = extractTable(ensuredBody, startMark, endMark);
            const map = parseTableToMap(middle);

            // Find latest incomplete sleep row (Sleep set, Wake empty), newest date first
            const findLatestIncompleteDateKey = () => {
              const keys = Array.from(map.keys()).sort((a, b) => (a < b ? 1 : -1));
              for (const k of keys) {
                const e = map.get(k);
                if (e && e.sleep && !e.wake) return k;
              }
              return null;
            };

            // Resolve target
            let appliedDateKey = null;
            let targetStamp = null; // always full "YYYY-MM-DD HH:MM" in UTC+8
            let source = 'live';

            if (!parsed.explicitTime) {
              // /sleep or /wake
              if (parsed.cmd === '/sleep') {
                appliedDateKey = dateKeyForSleepEvent(eventUtc8);
                targetStamp = eventStamp; // real time
              } else {
                // /wake: prefer incomplete row; stamp = real time
                appliedDateKey = findLatestIncompleteDateKey() || eventDateKey;
                targetStamp = eventStamp; // KEEP REAL DATE (important!)
              }
            } else if (parsed.explicitTime && !parsed.explicitDate) {
              // Disallow "/sleep HH:MM" and "/wake HH:MM"
              await comment(
                owner,
                repo,
                issue_number,
                `@${commenter} âš ï¸ ä¸æ”¯æŒ \`${parsed.cmd} HH:MM\` æ ¼å¼ã€‚\n` +
                  `ï¿½ï¿½ï¿½ä½¿ç”¨ï¼š\n` +
                  `- \`${parsed.cmd}\` è®°å½•å½“å‰æ—¶é—´\n` +
                  `- \`${parsed.cmd} YYYY-MM-DD HH:MM backfill\` è¡¥è®°/ä¿®æ­£ï¼ˆä»…å…è®¸æœ€è¿‘ ${BACKFILL_MAX_DAYS} å¤©ï¼‰`
              );
              return;
            } else if (parsed.explicitDate && parsed.explicitTime) {
              // /sleep YYYY-MM-DD HH:MM backfill
              // /wake  YYYY-MM-DD HH:MM backfill
              if (!parsed.isBackfill) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} âš ï¸ æŒ‡å®šæ—¥æœŸå’Œæ—¶é—´ä¿®æ”¹è®°å½•æ—¶ï¼Œå¿…é¡»åœ¨å‘½ä»¤æœ«å°¾åŠ ä¸Š \`backfill\` å…³é”®å­—ã€‚\n` +
                    `æ­£ç¡®æ ¼å¼ï¼š\`${parsed.cmd} ${parsed.explicitDate} ${parsed.explicitTime} backfill\``
                );
                return;
              }

              appliedDateKey = parsed.explicitDate;
              targetStamp = `${parsed.explicitDate} ${parsed.explicitTime}`;
              source = 'backfill';

              // Enforce 7-day window (inclusive)
              const todayKey = eventDateKey;
              const minAllowed = addDaysToUtc8DateKey(todayKey, -BACKFILL_MAX_DAYS);

              if (minAllowed && (appliedDateKey < minAllowed || appliedDateKey > todayKey)) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} âš ï¸ Backfill ä»…å…è®¸æœ€è¿‘ **${BACKFILL_MAX_DAYS}** å¤©ï¼ˆ**${minAllowed}** ~ **${todayKey}**ï¼‰ã€‚\n` +
                    `ä½ å°è¯•ä¿®æ”¹çš„æ—¥æœŸï¼š**${appliedDateKey}**`
                );
                return;
              }
            }

            if (!appliedDateKey || !targetStamp) return;

            const entry = map.get(appliedDateKey) || { sleep: '', wake: '', duration: '', source: '' };

            // Enforce "only once per day" unless backfill
            if (parsed.cmd === '/sleep' && entry.sleep && source !== 'backfill') {
              await comment(
                owner,
                repo,
                issue_number,
                `@${commenter} ${appliedDateKey} å·²ç»è®°å½•è¿‡ **Sleep**ï¼š**${entry.sleep}**ã€‚\n` +
                  `å¦‚éœ€ä¿®æ­£ï¼Œè¯·ä½¿ç”¨ï¼š\n` +
                  `\`/sleep ${appliedDateKey} HH:MM backfill\`\n` +
                  `ï¼ˆä»…å…è®¸æœ€è¿‘ ${BACKFILL_MAX_DAYS} å¤©ï¼Œä¸”åªèƒ½æŠŠæ—¶é—´æ”¹å¾—æ›´æ™šï¼‰`
              );
              return;
            }

            if (parsed.cmd === '/wake' && entry.wake && source !== 'backfill') {
              await comment(
                owner,
                repo,
                issue_number,
                `@${commenter} ${appliedDateKey} å·²ç»è®°å½•è¿‡ **Wake**ï¼š**${entry.wake}**ã€‚\n` +
                  `å¦‚éœ€ä¿®æ­£ï¼Œè¯·ä½¿ç”¨ï¼š\n` +
                  `\`/wake ${appliedDateKey} HH:MM backfill\`\n` +
                  `ï¼ˆä»…å…è®¸æœ€è¿‘ ${BACKFILL_MAX_DAYS} å¤©ï¼Œä¸”åªèƒ½æŠŠæ—¶é—´æ”¹å¾—æ›´æ™šï¼‰`
              );
              return;
            }

            // Handle /sleep
            if (parsed.cmd === '/sleep') {
              // é˜²æ­¢ backfill å¯¼è‡´ sleep >= wake
              if (entry.wake && targetStamp >= entry.wake) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} âŒ ä¸èƒ½æŠŠ **Sleep** è®¾ä¸º **${targetStamp}**ï¼Œå› ä¸ºå®ƒæ™šäºæˆ–ç­‰äºå·²è®°å½•çš„ **Wake**ï¼ˆ**${entry.wake}**ï¼‰ã€‚\n` +
                    `ğŸ’¡ å¦‚éœ€ä¿®æ­£ï¼Œè¯·å…ˆç”¨ backfill ä¿®æ­£ Wakeï¼Œæˆ–æ£€æŸ¥æ—¶é—´ã€‚`
                );
                return;
              }

              // Strategy B: never earlier
              if (!canSetField(entry.sleep, targetStamp, source === 'backfill', eventStamp)) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ä¸å…è®¸æŠŠ **Sleep** æ”¹å¾—æ›´æ—©ã€‚\nå½“å‰ï¼š**${entry.sleep || '(empty)'}**\nå°è¯•ï¼š**${targetStamp}**`
                );
                return;
              }

              entry.sleep = targetStamp;
            } else {
              // Handle /wake
              // é˜²æ­¢ backfill å¯¼è‡´ wake <= sleep
              if (entry.sleep && targetStamp <= entry.sleep) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} âŒ ä¸èƒ½æŠŠ **Wake** è®¾ä¸º **${targetStamp}**ï¼Œå› ä¸ºå®ƒæ—©äºæˆ–ç­‰äºå·²è®°å½•çš„ **Sleep**ï¼ˆ**${entry.sleep}**ï¼‰ã€‚\n` +
                    `ğŸ’¡ å¦‚éœ€ä¿®æ­£ï¼Œè¯·å…ˆç”¨ backfill ä¿®æ­£ Sleepï¼Œæˆ–æ£€æŸ¥æ—¶é—´ã€‚`
                );
                return;
              }

              // Strategy B: never earlier
              if (!canSetField(entry.wake, targetStamp, source === 'backfill', eventStamp)) {
                await comment(
                  owner,
                  repo,
                  issue_number,
                  `@${commenter} ä¸å…è®¸æŠŠ **Wake** æ”¹å¾—æ›´æ—©ã€‚\nå½“å‰ï¼š**${entry.wake || '(empty)'}**\nå°è¯•ï¼š**${targetStamp}**`
                );
                return;
              }

              entry.wake = targetStamp;
            }

            // Source: if any backfill ever touched this row, keep backfill
            if (entry.source !== 'backfill') {
              entry.source = source;
            }

            computeDuration(entry);
            map.set(appliedDateKey, entry);

            // Update issue body
            const rebuiltMiddle = rebuildMiddleFromMap(map);
            const finalBody = before + rebuiltMiddle + after;

            await github.rest.issues.update({
              owner,
              repo,
              issue_number,
              body: finalBody,
            });

            // Add BACKFILL_LABEL on issue if any backfill happened (best-effort)
            if (source === 'backfill') {
              const newLabels = Array.from(new Set([...(labels || []), BACKFILL_LABEL]));
              await github.rest.issues.update({
                owner,
                repo,
                issue_number,
                labels: newLabels,
              });
            }

            // Receipt comment
            const action = parsed.cmd === '/sleep' ? 'Sleep' : 'Wake';
            const extra = source === 'backfill' ? ' (backfill)' : '';
            await comment(owner, repo, issue_number, `Recorded **${action}**${extra}: **${targetStamp} (UTC+8)**`);
